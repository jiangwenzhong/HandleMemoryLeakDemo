# 背景

最近的项目总是遇到运行一个晚上后出现自动退出的问题，从日志分析是系统将应用进程杀掉了，由于ROM本身是我们基于Android7.1定制的，里面加了WatchDog，所以很有可能是由于应用某些异常导致整个系统卡死，从而引起了看门狗程序将应用杀掉，最有可能的原因就是应用程序内存的问题引起的【ROM本身放开了应用获取内存和存储空间的限制】，所以抽时间对整个应该进行了内存排查，发现了很多问题点，这里就列举其中遇到内存泄漏问题。

# 内存泄漏

## 现象

内存泄漏的现象就是经过某些操作或者程序运行一段时间后，整个应用程序占用的内存持续增加，并且GC无法回收这些分配出去的内存。

## 原因

内存泄漏的根本原因是由于引用关系处理不当导致的，当我们在写程序时，由于疏忽或者是对某些资源处理不当，造成了本应该被回收释放的资源没有得到正确的释放，从而造成我们的应用暂用的内存不断增加，最终程序变得卡顿，OOM，被系统杀死等。

## 常见引起内存泄漏的案例

1. 非静态内部类、匿名内部类
2. 静态的View
3. Handler
4. 监听器（各种需要注册的Listener，Watcher等）
5. 资源对象没关闭造成内存泄漏
6. 属性动画
7. RxJava
8. WebView
9. 其他的系统控件以及自定义View

参考：
[Android中常见的内存泄露及解决办法汇总](https://blog.csdn.net/unicorn97/article/details/81009204) 
[Android内存泄漏分析](https://cloud.tencent.com/developer/article/1399293)

## 引用类型

要想解决和避免内存泄漏，需要对引用类型有一个比较清晰的认识。

* 强引用：只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

* 软引用：用来描述一些还有用但并非必须的对象。在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。

* 弱引用：用户描述非必须对象的。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

* 虚引用：一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时刻得到一个系统通知。

参考：[java中的四种引用](https://blog.csdn.net/qq_33591903/article/details/82024257)

## 排查的工具

* leakcanary

	leakcanary是由Square公司基于MAT开源了一个内存泄漏检测工具，集成和使用都比较简单，集成方式可以参考[官方说明](https://github.com/square/leakcanary/blob/master/README-1.6.md)，需要注意的是，leakcanary不是所有的内存泄漏都可以检测出来，如无法检测出Service中的内存泄漏问题、如果最底层的MainActivity一直未走onDestroy生命周期(它在Activity栈的最底层)，无法检测出它的调用栈的内存泄漏。针对这些情况就只能使用MAT来分析了。

	参考:
[性能优化工具（九）-LeakCanary](https://www.jianshu.com/p/70b8c87ea877)

* android studio自带的profiler + MAT

	通过android studio提供的profiler其实已经可以看出一些问题了，通过profiler，我们可以监测某个进程的CPU、内存、网络的变化，在运行一段时间或者是执行了一系列应用的交互操作后，我们就可以先手动触发GC【将无用对象及非强引用对象回收】，接着dump一份当前内存，这时候就可以筛选出我们应用相关的类，来观察分配的对象个数是否合理来判断是否存在内存泄漏了，如果觉得有内存泄漏，则在将当前的内存快照保存下来，通过hprof-conv命令将这份内存快照转化成MAT可以解析的内存快照，通过MAT来分析。

	参考：
[性能优化 Profiler MAT 内存泄漏 堆转储 MD](https://www.cnblogs.com/baiqiantao/p/10575841.html)


# 代码

[HandleMemoryLeakDemo](https://github.com/jiangwenzhong/HandleMemoryLeakDemo)